# Project structure
In any project, it is important to have a well-defined structure of content to ensure easy localization of specific parts of the project. When working on reproducibility this is doubly important, as your work will need to be accessible and understandable to others as well as yourself. Software projects have guidelines on top of this: content is categorized based on their role in the project: is it input? Is it a tool that is used within the project? Is it generated by the project itself? The behavior of a file informs its location within your folder structure, and references to these files should be made within this context alone. All this to ensure that your project can be moved to another location, and run anew. 

In this part of the workshop we will address setting up a reproducible project structure. We will introduce best practices for a folder structure and how to refer to files within your project. Finally, we will look at how this process can be automated, so that someone reproducing your work (or using your software) can set up the project on their own system with minimal effort.


## Folders and paths

### Glossary
| Concept | Definition |
|:-----------:|:-------------|
| Root | The highest directory in the hierarchy of folders. This is the main drive in which all your other folders are stored. When working inside a project, the root folder is the main project folder, and will function as the working directory. |
| Path | The directions to a folder within your system. A path can be absolute, starting from the highest possible point in the hierarchy (for example, the C: drive), or relative, starting from a working directory. E.g.: `/Users/Barbara/example_project/src/analysis.py` is the absolute path to `analysis.py`, where `scripts/analysis.py` is the relative path from the project folder. |
| Working directory | |



### Setting up a project structure
A project is stored preferably in a dedicated folder, with subdirectories dividing the content into broad categories that define the behavior and role of the files within. Firstly, the **data** that forms the basis of your work will get its own, read-only `data` folder. It is important that the content of this folder does not change; your code will not edit it, nor will you. It will only be used as source material for the project during its analysis. The **code** that processes the data is stored in `src`, although you may opt to store the main script for your analysis in the root. This will create **output** in a separate `output` folder, for example figures or models, which by definition consists only of files that are generated by running your code. Manually edited files, such as **documentation**, or perhaps even your paper, live in the `docs` folder.

Summarizing:

#### `~` (root)
This folder:

- contains all the following subfolders.
- contains analysis scripts.
- contains installation instructions and/or makefile script.
- contains the project's main README.

#### `data`
This folder:

- contains (raw) research data, in read-only files.
- is filled at the start of the project, and may not be edited by you or your code during the project.
- may have subdirectories indicating e.g. different kinds of data (e.g. `images`).

Alternative folder name: `input/`

#### `output`
This folder:

- contains the output files produced by your analysis.
- can be deleted, and reproduced entirely by the analysis.
- may have subdirectories; e.g. `figs` or `models`.

Alternative folder name: `results/`


#### `src`
This folder:

- contains code.
- is never executed by itself: the content is limited to e.g. function definitions.
- may have subdirectories; e.g. `R`, `Python`, or `analysis`.

Alternative folder names: `scripts/`, `R/`


#### `doc`
This folder:

- contains the code documentation, perhaps even the paper.
- is edited during the project by the user.

Alternative folder name: `paper/`


### Absolute and relative paths
Each file in your system has an absolute location, that can be referred to with a 'path'. This is the absolute location of a file, and it can be tempting to use this path in your code when working with your files. For example, `/Users/Barbara/Project/data/patientdata_2018.csv`. However, this path does not exist outside of your system, which means that someone else using your code will first have to adjust these paths in the code before it can be run on their machine.

That is obviously not what we want. Even setting a working directory at a single point early in the script is not recommended: this, too, would mean that someone else working with your code will have to adjust it before they can get started.

Instead, we recommend using **relative** paths. Here, the path is described from the perspective of the root project folder. The above example would simply become `data/patientdata_2018.csv`. The project as a whole is copied to someone else's system, who will have no trouble running code referring to relative paths, as all necessary folder structures have been included with the project.

Keep in mind that this only works if code is run from the root of the project! The location from where the script is initiated, will be used as the start of the relative path. Compare for instance:

```sh
$ cd Project
$ python src/analysis.py
```

(this should work)

vs

```sh
$ python Project/src/analysis.py
python: can't open file 'test.py': [Errno 2] No such file or directory
```

(this gives an error, because `analysis.py` refers to `data/patientdata_2018.csv`, which does not exist in the home folder, but in the `Project` folder.)


### File naming
Take some time to consider file names you will use. A good set of guidelines (cf. [Jenny Bryan](https://jennybc.github.io/wtf-2019-rsc/project-oriented-workflow.pdf)) is to ensure your names are:

- machine-readable
- human readable
- sortable

The exact implementation for this may differ per language. For instance, R is fine with file names that start with numbers, and it may be a recommendation to implement this as it increases the sortability of your files. Python, on the other hand, does not allow variable names to start with numbers, thus starting file names with numbers should be discouraged for Python users. We encourage you to take some time to google and consider best practices for your language and project.

One rule that transcends program(ming language)s though, is to use the ISO 8601 standard for dates: YYYY-MM-DD. This ensures chronological sorting, and prevents any day-vs-month confusion between US and other users. 


### Examples
`{make folder tree to visualize the above. It should have a folder structure with proper file names}`

`{Write a bit of code that refers to files with absolute and relative paths}`


### Exercises

#### Class/discussion
- Move the file to the right folder (perhaps with a few ambiguous examples which can then be discussed in the group?)

#### Individual
- Create a folder structure like the one before for your own project (including subdirectories)
- Place a data file in the data folder, write a script that reads the datafile, generates an output file, and places it in the appropriate folder.}

#### Group project
- Create a folder structure like the one discussed before. Get consensus about the structure. 

## Automating the project structure

What **could** we want to automate?

- installing the required packages and dependencies
- generating the project structure
- analyse
- tests to determine whether the project can be run
- downloading data, filling up the data folder
- rendering documentation






## Links and inspiration dump

- [Noble et al 2009, Plos Comp Biol](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1000424)
- [NiceR code](https://nicercode.github.io/blog/2013-04-05-projects/)
- [Carl Boettiger's workflow](https://www.carlboettiger.info/2012/05/06/research-workflow.html)
- [Good Enough project management](https://journals.plos.org/ploscompbiol/article/file?id=10.1371/journal.pcbi.1005510&type=printable)

